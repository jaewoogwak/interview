# Computer Algorithm

## 선택 정렬(Selection Sort)

-   리스트에서 가장 작은 값을 찾고 맨 앞에 위치한 값과 교체한다.
-   맨 처음 위치를 뺀 나머지 범위의 리스트에 대해서도 같은 방법으로 교체한다.
-   하나의 원소만 남을 때까지 위 과정을 반복한다.
-   시간 복잡도: O(n^2)
-   ex) 9, 6, 7, 3, 5
-   #1) 3, 6, 7, 9, 5
-   #2) 3, 5, 7, 9, 6
-   #3) 3, 5, 6, 9, 7
-   #4) 3, 5, 6, 7, 9

## 삽입 정렬(Insertion Sort)

-   리스트에서 n번째(2~마지막)요소를 앞 요소들 사이의 올바른 위치에 삽입한다.
-   마지막 요소를 삽입하면 리스트가 정렬된다.
-   이때 n번째 요소 앞 범위 리스트는 정렬된 것을 보장할 수 있다.
-   시간복잡도는 최선의 경우 O(n)로 리스트가 정렬된 상태이며, 최악의 경우 역순으로 정렬된 경우 O(n^2)이다.
-   ex) 8, 5, 6, 2, 4
-   #1) 5, 8, 6, 2, 4
-   #2) 5, 6, 8, 2, 4
-   #3) 2, 5, 6, 8, 4
-   #4) 2, 4, 5, 6, 8

## 버블 정렬(Bubble Sort)

-   리스트에서 서로 인접한 두 요소끼리 비교하여 크기가 순서대로 되어 있지 않으면 교체한다.
-   1회전을 수행하면 가장 큰 요소가 맨 뒤에 위치하게 되므로 맨 끝에 있는 자료는 2회전에선 제외한다.
-   최선, 최악의 경우 모두 O(n^2)이다.
-   ex) 7, 4, 5, 1, 3
-   #1) 4, 5, 1, 3, 7
-   #2) 4, 1, 3, 5 ,7
-   #3) 1, 3, 4, 5, 7
-   #4) 1, 3, 4, 5 ,7
-

## 병합 정렬(Merge Sort)

-   리스트를 두 개의 균등한 크기로 분할하고 분할된 리스트를 정렬한 뒤, 정렬된 부분 리스트를 합쳐서 전체가 정렬된 리스트로 만든다.
-   Divide: 입력 배열을 같은 크기 2개의 부분 배열로 분할한다.
-   Conquer: 부분 배열을 정렬한다. 만약 부분 배열이 충분히 작지 않으면 다시 분할한다.
-   Combine: 정렬된 부분 배열을 하나의 배열로 만든다.
-   추가적인 리스트가 필요하며 실제 정렬이 이루어지는 시점은 2개의 정렬된 부분 리스트를 병합(merge)하는 단계이다.
-   최선, 최악의 경우 모두 O(nlog(n))의 시간복잡도를 가진다.

## 퀵 정렬(Quick Sort)

-   분할 정복 기반 정렬 알고리즘으로 피봇을 중심으로 리스트를 나누어 피봇보다 작은 값, 큰 값으로 분할하여 정렬한다.
-   병합 정렬과 다르게 비균등 분할이다.
-   시간 복잡도는 O(nlog(n))이며, 최악의 경우(이미 리스트가 정렬된 경우) O(n^2)이다.
-   단순하게 첫번째나 마지막을 피벗으로 선택할 경우 이미 정렬된 리스트에서는 분할이 항상 한쪽으로 치우치게 되어 비효율적인 정렬이 발생한다.

## 힙 정렬(Heap Sort)

-   주어진 데이터를 힙 자료구조로 만들어 최댓값 혹은 최솟값부터 하나씩 꺼내서 정렬하는 알고리즘이다.
-   시간 복잡도는 O(nlog(n))이다.

## BFS

-   루트 노드에서 시작하여 인접한 노드부터 탐색하는 방법이다.
-   두 노드 사이의 최단 경로나 임의의 경로를 찾고자 할 때 사용할 수 있다.
-   큐로 구현할 수 있다.

## DFS

-   루트 노드에서 시작하여 다음 분기로 넘어가기 전에 현재 분기를 완벽하게 탐색하는 방법이다.
-   재귀 또는 스택으로 구현할 수 있다.

## 동적 계획법(Dynamic Programming)

-   주어진 문제를 풀기 위해 문제를 여러 개의 하위 문제로 나누어 푸는 방법이다.
-   하위 문제(부분 문제)가 다른 문제를 해결하는 데에 사용될 수 있어서 하위 문제의 답을 저장해놓고 필요할 때 바로 사용할 수 있다. (메모이제이션)

## DP와 분할정복의 공통점과 차이점

-   두 방법 모두 문제를 작은 문제로 나누어 해결한다는 것이 공통점이다.
-   그러나 분할정복은 소문제가 중복되지 않는 반면 DP는 소문제가 중복되어 메모이제이션을 활용한다.

## 다익스트라 알고리즘

-   각 노드에서 다른 모든 노드로의 최단 경로를 구할 수 있는 알고리즘
-   시작 노드에서 도달할 수 있는 노드까지 거리 비용을 구하고, 그 중 가장 가까운 노드부터 방문한다. 새로운 노드를 방문하면 시작 노드로부터 다른 노드까지의 거리 비용을 새롭게 갱신한다. 이 과정을 반복하면서 각 노드에 대해 모든 노드로의 최단 경로를 구할 수 있다.
-   방문하지 않은 노드 중 가장 가까운 노드부터 방문하는 알고리즘은 순차 탐색 or 우선순위 큐를 사용할 수 있다.
-   순차 탐색을 사용하면 다익스트라 알고리즘은 O(n^2)이고 우선순위 큐를 사용하면 O(nlog(n))이다.
-   실제 사용 사례로는 네비게이션에서 목적지를 설정하여 이동할 때 활용할 수 있다.
-   O(Elog(V))

## 벨만 포드 알고리즘

-   다익스트라 알고리즘은 방문하지 않은 노드 중 가장 가까운 노드를 방문하는데, 이때 음수 간선이 있다면 최적해를 찾을 수 없다.
-   벨만 포드 알고리즘은 모든 간선을 확인하기 때문에 음수 간선이 있어도 최적해를 찾을 수 있다.
-   O(EV)이다.

## P-NP

-   결정문제: 답이 참 또는 거짓인 문제. S = {true, false}
-   P 문제: 다항시간 내에 해결할 수 있는 결정문제
-   NP 문제: 다항시간 내에 해결할 수 있는 비결정문제
    -   이때 비결정문제를 힌트가 주어졌을 때 검증하는 문제로 대체 가능
-   P=NP or P!=NP는 어떤 문제가 검산하기 쉽다면 그 문제를 쉽게 풀 수 있는가에 대한 것임.
